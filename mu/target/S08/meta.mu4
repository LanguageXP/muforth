( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2018 David Frech. (Read the LICENSE for details.)


loading S08 Meta-compiler (main)

( Make it easy to check if a device register has been defined. If device
  equates move to somewhere other than .equates. update this too.)
compiler
: .reg   .equates. \ .contains ;
forth
: .reg   \ .reg ;


( Support for looking back at previously compiled code.)
variable last-code  ( pointer to beginning of last snippet of code)
: code!   \m here  last-code ! ;

compiler
: asm{                   __inline-asm ;  ( don't reset last-code)
: code{   compile code!  __inline-asm ;  ( reset last-code)
: }       ] ;  ( exit inline assembler mode and restart colon compiler)


( Make it easy to make assembler macros.)
meta
: macro           current preserve       assembler  :  __inline-asm ;

forth
: macro   \m macro ;


-- ------------------------------------------------------------------------
-- Stack layout
-- ------------------------------------------------------------------------

( To make use of literals easier, we keep two "scratch" bytes allocated on
  the D stack, at 0,x and 1,x. Below this is top, and below that, second.
  Like this:

     |      |      |
     +------+------+
  4  |  sh  |  sl  |  5   second
     +------+------+
  2  |  th  |  tl  |  3   top
     +------+------+
  0  |  xh  |  xl  |  1   scratch
     +------+------+
)

macro sl  5 ,x ;
macro sh  4 ,x ;
macro tl  3 ,x ;
macro th  2 ,x ;
macro xl  1 ,x ;
macro xh  0 ,x ;

( And for double-length values:)

macro ds0  9 ,x ;  ( double second, lsb)
macro ds1  8 ,x ;
macro ds2  7 ,x ;
macro ds3  6 ,x ;  ( double second, msb)
macro dt0  5 ,x ;  ( double top, lsb)
macro dt1  4 ,x ;
macro dt2  3 ,x ;
macro dt3  2 ,x ;  ( double top, msb)


-- ------------------------------------------------------------------------
-- Literal loading.
-- ------------------------------------------------------------------------
--
-- The low half is put into A, the high half into xh - 0,x, on the data
-- stack.
--
-- If high half and low half are equal and non-zero,
--    half # lda  xh sta  ( 3 bytes)
-- Otherwise:
--
-- High half:
-- If hi =  0, xh clr          ( 1 byte)
-- If hi =  1, xh clr  xh inc  ( 2 bytes)
-- If hi = -1, xh clr  xh dec  ( 2 bytes)
-- Otherwise, #hi lda  xh sta  ( 3 bytes)
--
-- Low half:
-- If lo =  0, .a clr  ( 1 byte)
-- Otherwise, #lo lda  ( 2 bytes)
-- ------------------------------------------------------------------------

: load-hi  ( hi)
   dup              0= if  drop  code{  xh clr } ^  then
   dup             1 = if  drop  code{  xh clr  xh inc } ^  then
   dup "0ff and "0ff = if  drop  code{  xh clr  xh dec } ^  then
                                 code{   # lda  xh sta } ;

: load-lo  ( lo)
    ?if  code{  # lda } ^  then
         code{ .a clr } ;

: load-literal  ( n)
   >lohi  2dup = if  =if  ( if hi & lo are equal and non-zero)
      drop  code{  # lda  xh sta } ^  then  then
   load-hi  load-lo ;

( XXX - does it make more sense - it certainly makes the generated code
  more readable - to store A in xl and then promote the scratch cell to top?
  And to do the reverse with pop-literal?)

( With a literal in A and xh, push it onto the D stack.)
macro push-literal  ( A -> tl, xh -> th)
   -2 # aix ( xh -> th)  tl sta ;

macro push-literal-alt  ( A -> xl, then promote scratch to top)
   xl sta  -2 # aix ;

( Pop top of D stack into A and xh, just as if they were loaded by
  load-literal. This is used to make versions of binary operations that
  work either with true literals, or with a value sitting on the D stack.)

macro pop-literal   ( tl -> A, th -> xh)
   tl lda  2 # aix  ( th -> xh) ;

macro pop-literal-alt   ( top -> scratch, then load A from xl)
   2 # aix  ( demote top to scratch)  xl lda ;

meta
: literal  ( n)  code{  load-literal }
                 code{  push-literal } ;

: compile,  ( target-cfa)  code{  c }  ( compile call) ;

forth

( Since address 0 is in the i/o register range, we will never jsr there, so
  we can return 0 as "no call found".)
: called  ( - dest-addr)
   last-code @  dup image-c@  ( op)
   dup "ad = if ( bsr)  drop  dup 1+ image-c@ ( offset)  sext  2 + +a ^ then
   dup "bd = if ( jsr dir)  drop  1+ image-c@ ^  then
   dup "cd = if ( jsr ext)  drop  1+ image-@  ^  then
   2drop  0 ;

: replace  ( addr jsr-op jmp-op - -1)
   rot image-c!  drop  -1 ;

( If last code compiled was a call, rewrite it to a jump and return true;
  else return false.)

: tail?  ( - f)
   last-code @  dup image-c@  ( op)
   dup "ad = if ( bsr)      "20 ( bra)      replace ^  then
   dup "bd = if ( jsr dir)  "bc ( jmp dir)  replace ^  then
   dup "cd = if ( jsr ext)  "cc ( jmp ext)  replace ^  then
   2drop  0 ;

target-compiler
: ^   tail? if ^ then  code{  rts } ;

forth
: ?retreat  ( f)  if  last-code @  \m goto ^  then ;
: lit?   last-code @  image-c@ "af ( aix) =  dup ?retreat ;

: _litop  current preserve  target-compiler  create  __asm
          does>  lit?  if  cell+  then  @  \m compile, ;

meta
: litop
   _litop
      \m here  ( stack entry point)  ,
      code{  pop-literal }
      \m here  ( literal entry point)  , ;

: relop
   _litop
      \m here  ( literal entry point)
      code{  push-literal }
      \m here  ( stack entry point)  ,  , ;

forth


( Create a new target name. A target word is defined as a _constant_ equal
  to its code field address.)

meta
: label   \m here  current preserve    meta constant  __asm ;
: name    \m here  current preserve  target constant ;
: code    \m name  __asm ;
: :       \m name  __target-colon ;

:  ]   __target-colon ;
: #]   \m literal  \m ] ;

( For forward references)
: forward-jmp   "100 \a ) \a jmp  \m label ;
: forward-jsr   "100 \a ) \a jsr  \m label ;
: resolve>>  ( src)  \m here  swap 2 -  image-! ;

: '  .target. chain' execute ;  ( target words are constants!)

: __host  \ [ ;  ( return to host forth mode)
: {    \m __host ;  ( useful for bracketing a few  host forth words)

forth
: }    __meta ;  ( return to meta)

assembler
: ;c   __meta ;

target-compiler
: [   __meta ;
: ;   \tc ^  \tc [ ;  ( return to meta)

compiler
: ;m   \ ;  __meta ;  ( exit macro compilation and return to __meta)

forth


( Alloting RAM space to variables.)
( XXX Should I assume space for stack? Things are bad _before_ we've come
  to the actual end of RAM...)

( zvar grows up from @ram; xvar grows down from "0100. If they cross, throw
  an error.)

( We don't do  h preserve  because our caller already has.)
: ?zpage
   xram \m here  zram \m here  u<
   if error" No available zero-page ram" then ;

meta
: var   ( bytes)
   h preserve  ram   \m here equ  \m allot
   [ @ram #ram + #]  \m here  u<  if error" No available ram"  then ;

: zvar  ( bytes)
   h preserve  zram  \m here equ  \m allot  ?zpage ;

: xvar  ( bytes)
   h preserve  xram  negate \m allot  \m here equ  ?zpage ;

forth

( Utility macros.)
macro pshhx  .x psh  .h psh         ;
macro pulhx          .h pul  .x pul ;


( Calculation of FCDIV - flash clock divider [sic]

  FCDIV = ceil[busclock/200k] - 1

  We leave off the - 1 to slow the flash a bit. Insurance against our clock
  being a bit fast... better to have the flash clock run a bit slow than
  too fast.

  We're trying the divide the bus clock down to between 150kHz and 200kHz,
  to drive the flash programming machinery. We need to calculate a divider
  that works. One caveat: if the calculated value is > 63, set a bit that
  first divides the bus clock by 8 before dividing by our divider
  [actually, our divider + 1].)

( For utmost resolution, clock speed is in hertz.)
: hz>fcdiv  ( clock-in-hz - fcdiv)
   199,999 +  200,000 /
   dup 64 u< not if
      ( too big - round up and divide by 8)  7 + 3 >>
      ( set "divide by 8" bit)  "40 or
   then ;

( For most uses: clock speed is in kilohertz.)
: khz>fcdiv  ( clock-in-khz - fcdiv)
   1,000 *  hz>fcdiv ;

( Interrupt vectors and handlers.)
variable vector-offset  ( 0 if vectors not relocated)
: reloc-vector  ( offset - offset')
   dup \eq Vreset = if ^ then  ( reset doesn't get relocated)
   vector-offset @ +a ;

meta
: handler  ( vector-offset)
   reloc-vector  \m here swap  image-!  __asm ;

forth

( Patch target colon compiler.)
.meta. chain' literal   is target-literal
             ' number   is target-number    ( use host's number)
.meta. chain' compile,  is target-compile,
