( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2019 David Frech. (Read the LICENSE for details.)

loading RISC-V serial chat protocol (core)

( Taking inspiration from the wildly successful S08 serial chat protocol.

  Responds to the following commands. NOTE: these are hex values!

00 - 0f  idle   - these command bytes are ignored

10  version     - get the 32-bit version commit
11  set address - set the memory address pointer
12  read words  - read N words, incrementing by 4 as we go
13  write word  - write a word to memory, incr pointer by 4
14  get sp      - get sp
15  run         - set pc and sp and execute

16 - ff  idle   - these command bytes are ignored
)

__meta
hex

abi-regs

( Forward references.)
hook reset-entry
hook chat-entry

( Our two "millicode" routines.)
( lr should be something outside of C reg set; we are using standard ABI
  "alternate link register" x5/t0.)
label nest
   -2 cells sp c.addi   0 ra c.swsp  cell s0 c.swsp   t0 c.jr  ;c

label unnest
   0 ra c.lwsp  cell s0 c.lwsp   2 cells sp c.addi   t0 c.jr  ;c

label exit
   unnest t0 jal   ra c.jr  ;c

assembler
: cc     asm{  c.jal  } ;     ( compressed call)
: cj     asm{  c.j    } ;     ( compressed jump)
: cret   asm{  ra c.jr  } ;   ( compressed return)

: {{    asm{    nest t0 jal  } ;
: }}    asm{  unnest t0 jal  } ;
: }};   asm{    exit    c.j  } ;
forth

label drain
   uart0.rxdata >ui a1 lui
   begin   uart0.rxdata >li a1 a0 c.lw   a0 0< until
   cret  ;c

label b>  ( - b)
   uart0.rxdata >ui a1 lui
   begin   uart0.rxdata >li a1 a0 c.lw   a0 0>= until
   "0ff a0 a0 andi   cret  ;c

label >b  ( b)
   uart0.txdata >ui a1 lui
   begin   uart0.txdata >li a1 a2 c.lw   a2 0>= until
   uart0.txdata >li a1 a0 c.sw   cret  ;c

label w>
   {{  b> cc                   a0 s0 c.mv
       b> cc    #8 a0 c.slli   a0 s0 c.add
       b> cc   #16 a0 c.slli   a0 s0 c.add
       b> cc   #24 a0 c.slli   s0 a0 c.add  }};

label >w
   {{      a0 s0 c.mv      >b cc
       s0  #8 a0 srli      >b cc
       s0 #16 a0 srli      >b cc
       s0 #24 a0 srli  }}  >b cj  ;c

( Compile the first 32 bits of the current muforth Git commit. When called,
  send the commit and our PC so the host can tell if we are running from
  flash or ram.)

label version
   {{  muforth-commit drop 8 evaluate
       dup >ui a0 lui   >li a0 a0 addi       >w cc
                             0 a0 auipc  }}  >w cj  ;c

label set-address
   {{  w> cc   a0 s1 c.mv  }};

label read-words
   {{  b> cc ( count)  a0 0!= if   a0 s0 c.mv
       begin    0 s1 a0 c.lw   cell s1 c.addi   >w cc
               -1 s0 c.addi   s0 0= until
       then
   }};

label write-word
   {{  w> cc   0 s1 a0 c.sw   cell s1 c.addi  }};

label get-sp
   tp a0 c.mv   >w cj  ;c

.ifdef using-ecall

( We don't return, so we don't bother to save our ra.)
label run
   w> cc  ( pc)   a0 mepc csrw
   w> cc  ( sp)   a0   tp c.mv   mret  ;c

.else

( We don't return, so we don't bother to save our ra.)
label run
   w> cc  ( pc)  a0 s0 c.mv
   w> cc  ( sp)  a0 tp c.mv   s0 c.jr  ;c

.then

( For ease of compilation I've cheated and hardwired in both the command
  offset and the max index of the table. Tread carefully if you change
  either of these!)

label dispatch
   -10 a0 c.addi  ( 00 to 0f become large unsigned numbers)
    6 a1 c.li   a0 a1 u< if                  (  4             2           4)
       a0 a0 c.add ( halfword index)   0 a1 auipc   a1 a0 c.add   #10 a0 jr

      ( cmd table)
      ( 10) version c.j
      ( 11) set-address c.j
      ( 12) read-words c.j
      ( 13) write-word c.j
      ( 14) get-sp c.j
      ( 15) run c.j

   then  cret  ;c

label interact   hooks chat-entry
   begin   b> cc ( cmd)   dispatch cc   cj  ( again)  ;c

label uart-init
   uart0.txdata >ui a1 lui  ( get address of UART0 block)
   1 a0 li   uart0.txctrl >li a1 a0 sw  ( set txen)
             uart0.rxctrl >li a1 a0 sw  ( set rxen)
   #16,000,000 2* #115200 / 1+ 2/ 1-  ( divisor) a0 li   uart0.div >li a1 a0 sw

   ( Set GPIO IOF bits to allow UART to talk to pins. UART0 is pins 16 & 17.)
   gpio.iof_en >ui a1 lui
   gpio.iof_en >li a1 a2 addi  ( full address)
      0003_0000 a0 lui   ( mask with bits 16 and 17 set)
      a2 a0 x0 amoor.w   ( addr src dest)
   gpio.iof_sel >li a1 a2 addi  ( full address)
      a0 a0 not          ( mask with bits 16 and 17 clear)
      a2 a0 x0 amoand.w  ( addr src dest)
   cret  ;c

label >hfxosc
   hfxosccfg >ui a1 lui
   hfxosccfg >li a1 a2 addi  ( full address)
      4000_0000 a0 lui  ( enable)
      begin   a2 a0 a3 amoswap.w   a3 0< until  ( until ready bit)
   pllcfg >li a1 a2 addi  ( full address)
      0007_0000 a0 lui  ( pllbypass+pllrefsel+pllsel)
      a2 a0 x0 amoor.w
   cret  ;c

( At reset the SPI interface that reads the flash is set to run at 1/8 of
  the cpu/bus clock speed. The formula is f/2*[div+1], where f is the
  CPU/bus clock speed, and div is the value stored in the spi0.sckdiv
  register. At reset sckdiv is set to 3.

  We are planning to run at 16 MHz. It would be nice to run the SPI also at
  16 MHz but the minimum divisor we can get is 2, by setting div to zero.)

label set-spi-speed
   0 a0 li   spi0.sckdiv dup >ui a1 lui   >li a1 a0 sw   cret  ;c

label do-reset   hooks reset-entry
   @ram #ram + sp lui
   uart-init cc
   >hfxosc cc
   set-spi-speed cc
   drain cc
   interact cj  ;c

{ h @ }  ram

( Support for programming the SPI flash. We only compile these words when
  in-ram is defined. We can't run this code while executing chat from
  flash, because the memory-mapped mode of the SPI controller has been
  switched off.)

( Room for opcode, 3 address bytes, and 256 bytes of data.)
label spi-buf   104 allot

label >spi-prog-io
label >spi-mem-mapped
label cs\
label cs/
label spi-packet


.ifdef in-ram

( XXX for testing)
label one
   {{  b> cc  }}  dispatch cj  ;c

.then

label push2
   -8 tp c.addi   0 tp a0 sw   4 tp a1 sw   cret  ;c

label my-get-regs
   ra a0 c.mv   sp a1 c.mv   push2 cj  ;c

label exec
   -- @ram #ram + sp lui
   0 tp a0 lw   a0 c.jalr   0 tp a0 sw
.ifdef openocd
   ebreak
.else
   .ifdef chat-in-ram
      "8000_3004 j
   .else
      @app 4 +  dup >ui a0 lui   >li a0 jr
   .then
.then  ;c

label exec2
   0 tp a0 lw   a0 c.jalr
.ifdef openocd
   ebreak
.else
   .ifdef chat-in-ram
      "8000_3004 j
   .else
      @app 4 +  dup >ui a0 lui   >li a0 jr
   .then
.then  ;c

{ h ! }

__host

variable ta0
: rx   ( 'code)  stack>  \m exec runwait  stack<  ta0 !  .regs ;

: rx2   ( 'code)  stack>  \m exec2 runwait  stack< ;

-:
   cr  ."       A0        SP"
       (  00000000  00000000 )
   cr      ta0 .tr   tsp .tr ;
   is .regs

__meta


.ifdef notyet

label handle-interrupt
   ( ignore for now)
label exit-handler
   w x y pop3   mret  ;c

code handler
   w x y push3
   mcause w csrr  w 0>=  handle-interrupt until

( At "reset" we jump here.)
code reset
   @ram #ram +  sp lui  ( locate stack at end of ram)

   ( set up clock - 16M HFXOSC)

   ( set up uart - 115200 - divisor 138)

   ( set up mtvec to point to a handler that includes chat-entry)

.then
